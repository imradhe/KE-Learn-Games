<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Projectile Motion Simulation Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #gameCanvas {
            border: 1px solid #000;
            background-color: #fff;
            cursor: pointer;
        }
        #controls {
            margin-left: 20px;
        }
        input[type="range"] {
            width: 200px;
        }
    </style>
</head>
<body>
    <div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="controls">
            <label for="velocitySlider">Velocity: <span id="velocityValue">50</span> m/s</label>
            <input type="range" id="velocitySlider" min="10" max="100" value="50"><br>
            <button id="fireButton">Fire!</button>
            <p>Click and drag the cannon to adjust angle.</p>
            <p>Click and drag the base to adjust height.</p>
            <p>Click and drag the target to adjust distance.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const velocitySlider = document.getElementById('velocitySlider');
        const fireButton = document.getElementById('fireButton');

        let angle = 45;
        let velocity = 50;
        let baseHeight = 50;
        let targetDistance = 300;
        let projectileX = 0;
        let projectileY = 0;
        let time = 0;
        let animationId = null;

        let isDragging = false;
        let dragTarget = null;

        function updateVelocityValue() {
            document.getElementById('velocityValue').textContent = velocity;
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw base
            ctx.fillStyle = 'brown';
            ctx.fillRect(0, canvas.height - baseHeight, 50, baseHeight);

            // Draw cannon
            ctx.fillStyle = 'gray';
            ctx.beginPath();
            ctx.arc(25, canvas.height - baseHeight, 20, 0, Math.PI * 2);
            ctx.fill();

            // Draw cannon barrel
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(25, canvas.height - baseHeight);
            ctx.lineTo(25 + Math.cos((90 - angle) * Math.PI / 180) * 40, canvas.height - baseHeight - Math.sin((90 - angle) * Math.PI / 180) * 40);
            ctx.stroke();

            // Draw target
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(targetDistance, canvas.height - 20, 20, 0, Math.PI * 2);
            ctx.fill();

            // Draw projectile
            if (animationId) {
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(projectileX, canvas.height - projectileY, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw labels
            ctx.fillStyle = 'black';
            ctx.font = '14px Arial';
            ctx.fillText(`Angle: ${angle.toFixed(1)}Â°`, 10, 20);
            ctx.fillText(`Base Height: ${baseHeight.toFixed(1)}m`, 10, 40);
            ctx.fillText(`Target Distance: ${targetDistance.toFixed(1)}m`, 10, 60);
        }

        function updateProjectile() {
            const g = 9.8; // Acceleration due to gravity (m/s^2)
            const radianAngle = angle * Math.PI / 180;

            projectileX = velocity * Math.cos(radianAngle) * time;
            projectileY = baseHeight + (velocity * Math.sin(radianAngle) * time) - (0.5 * g * time * time);

            if (projectileY < 0 || projectileX > canvas.width) {
                cancelAnimationFrame(animationId);
                animationId = null;
                checkHit();
            } else {
                time += 0.1;
                animationId = requestAnimationFrame(updateProjectile);
            }

            drawScene();
        }

        function checkHit() {
            const distance = Math.sqrt(Math.pow(projectileX - targetDistance, 2) + Math.pow(projectileY - 20, 2));
            if (distance < 25) {
                alert('Hit! Great shot!');
            } else {
                alert('Miss! Try again.');
            }
        }

        function fireProjectile() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            projectileX = 25;
            projectileY = baseHeight;
            time = 0;
            updateProjectile();
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (Math.sqrt(Math.pow(mouseX - 25, 2) + Math.pow(mouseY - (canvas.height - baseHeight), 2)) < 20) {
                isDragging = true;
                dragTarget = 'cannon';
            } else if (mouseX < 50 && mouseY > canvas.height - baseHeight) {
                isDragging = true;
                dragTarget = 'base';
            } else if (Math.sqrt(Math.pow(mouseX - targetDistance, 2) + Math.pow(mouseY - (canvas.height - 20), 2)) < 20) {
                isDragging = true;
                dragTarget = 'target';
            }
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            switch (dragTarget) {
                case 'cannon':
                    const dx = mouseX - 25;
                    const dy = (canvas.height - baseHeight) - mouseY;
                    angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    angle = Math.max(0, Math.min(90, angle));
                    break;
                case 'base':
                    baseHeight = canvas.height - mouseY;
                    baseHeight = Math.max(10, Math.min(200, baseHeight));
                    break;
                case 'target':
                    targetDistance = mouseX;
                    targetDistance = Math.max(100, Math.min(700, targetDistance));
                    break;
            }

            drawScene();
        }

        function handleMouseUp() {
            isDragging = false;
            dragTarget = null;
        }

        velocitySlider.addEventListener('input', () => {
            velocity = parseInt(velocitySlider.value);
            updateVelocityValue();
        });

        fireButton.addEventListener('click', fireProjectile);

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        updateVelocityValue();
        drawScene();
    </script>
</body>
</html>